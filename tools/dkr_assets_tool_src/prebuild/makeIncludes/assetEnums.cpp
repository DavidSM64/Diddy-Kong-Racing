#include "assetEnums.h"

#include "helpers/assetsHelper.h"
#include "helpers/stringHelper.h"
#include "helpers/c/cEnumsHelper.h"

AssetEnums::AssetEnums(DkrAssetsSettings &settings) : _settings(settings) {
    _outFilepath = _settings.pathToInclude / "asset_enums.h";
    
    _cHeader.write_comment("This file is automatically generated. Any changes you make to this file will get overwritten.");
    _cHeader.write_newline();
    
    _cHeader.write_raw_text_line("#ifndef _ASSET_ENUMS_H");
    _cHeader.write_raw_text_line("#define _ASSET_ENUMS_H");
    _cHeader.write_newline();
    
    _cHeader.write_header_comment("Asset Sections");
    _write_asset_section_enums();
    _cHeader.write_newline();
    
    _cHeader.write_raw_text_line("#endif");
    
    _cHeader.save(_outFilepath);
}

AssetEnums::~AssetEnums() {
    
}

void AssetEnums::_write_asset_section_enums() {
    JsonFile *mainJson = AssetsHelper::get_main_json(_settings);
    
    std::vector<std::string> mainOrder;
    mainJson->get_array<std::string>("/assets/order", mainOrder);
    
    _write_main_asset_enum(mainOrder);
    
    for(std::string &sectionId : mainOrder) {
        JsonFile *sectionJson = AssetsHelper::get_asset_section_json(_settings, sectionId);
        
        if(sectionJson != nullptr) {
            if(sectionJson->has("/files")) {
                _cHeader.write_newline();
                _cHeader.write_header_comment(sectionId.c_str());
                _write_asset_section_enums(sectionId, sectionJson);
            } else if(sectionJson->has("/filename")) {
                _write_single_asset_section_enums(sectionId, sectionJson);
            }
            continue;
        }
        
        std::string sectionPtr = "/assets/sections/" + sectionId;
        
        bool isDeferred = mainJson->get_bool(sectionPtr + "/deferred");
        
        if(isDeferred) {
            std::string deferInfoPtr = sectionPtr + "/defer-info";
            _cHeader.write_newline();
            _cHeader.write_header_comment(sectionId.c_str());
            _write_deferred_asset_section_enums(sectionId, mainJson, deferInfoPtr);
        }
    }
}

void AssetEnums::_write_main_asset_enum(std::vector<std::string> &mainOrder) {
    WriteableCEnum mainEnum("AssetSectionsEnum");
    for(std::string &sectionId : mainOrder) {
        mainEnum.add_symbol(sectionId);
    }
    _cHeader.write_raw_text(mainEnum.to_string());
}

void AssetEnums::_write_single_asset_section_enums(const std::string &sectionId, JsonFile *sectionJson) {
    if(sectionId != "ASSET_FONTS") {
        return; // This function is just for the fonts.
    }
    _cHeader.write_newline();
    _cHeader.write_header_comment(sectionId.c_str());
                
    std::string sectionEnumName = StringHelper::upper_snake_case_to_pascal_case(sectionId) + "Enum";
    WriteableCEnum sectionEnum(sectionEnumName);
    
    fs::path fontSubfolder = sectionJson->get_path("/folder");
    fs::path fontJsonPath = _settings.pathToAssets;
    if(!fontSubfolder.empty()) {
        fontJsonPath /= fontSubfolder;
    }
    fontJsonPath /= sectionJson->get_string("/filename");
    JsonFile *fontsJson;
    DebugHelper::assert(JsonHelper::get().get_file(fontJsonPath, &fontsJson),
        "(AssetEnums::_write_single_asset_section_enums) Could not load fonts json!");
        
    std::vector<std::string> fontIds;
    fontsJson->get_array<std::string>("/fonts-order", fontIds);
    for(std::string &fontId : fontIds) {
        sectionEnum.add_symbol(fontId);
    }
    
    _cHeader.write_raw_text(sectionEnum.to_string());
}


void AssetEnums::_write_asset_section_enums(const std::string &sectionId, JsonFile *sectionJson) {
    std::string sectionEnumName = StringHelper::upper_snake_case_to_pascal_case(sectionId) + "Enum";
    WriteableCEnum sectionEnum(sectionEnumName);
    
    std::vector<std::string> sectionOrder;
    sectionJson->get_array<std::string>("/files/order", sectionOrder);
    
    for(std::string &assetBuildId : sectionOrder) {
        sectionEnum.add_symbol(assetBuildId);
    }
    
    _cHeader.write_raw_text(sectionEnum.to_string());
    
    if(sectionId == "ASSET_MENU_TEXT") {
        std::string menuTextIdsEnumName = StringHelper::upper_snake_case_to_pascal_case(sectionId) + "IdsEnum";
        WriteableCEnum menuTextIdsEnum(menuTextIdsEnumName);
        
        std::vector<std::string> menuTextIds;
        sectionJson->get_array<std::string>("/menu-text-build-ids", menuTextIds);
        for(std::string &textId : menuTextIds) {
            menuTextIdsEnum.add_symbol(textId);
        }
        
        _cHeader.write_newline();
        _cHeader.write_raw_text(menuTextIdsEnum.to_string());
    }
}

void AssetEnums::_write_deferred_asset_section_enums(const std::string &sectionId, JsonFile *mainJson, const std::string &deferInfoPtr) {
    std::string sectionEnumName = StringHelper::upper_snake_case_to_pascal_case(sectionId) + "Enum";
    WriteableCEnum sectionEnum(sectionEnumName);
    
    std::string fromSectionId = mainJson->get_string(deferInfoPtr + "/from-section");
    std::string idPostfix = mainJson->get_string(deferInfoPtr + "/id-postfix");
    
    JsonFile *fromSectionJson = AssetsHelper::get_asset_section_json(_settings, fromSectionId);
    
    std::vector<std::string> sectionOrder;
    fromSectionJson->get_array<std::string>("/files/order", sectionOrder);
    
    for(std::string &assetBuildId : sectionOrder) {
        // TODO: This only works for LevelNames. 
        //       Will need to be modified later since Object Animations aren't one-to-one with Object Models.
        sectionEnum.add_symbol(assetBuildId + idPostfix);
    }
    
    _cHeader.write_raw_text(sectionEnum.to_string());
}
